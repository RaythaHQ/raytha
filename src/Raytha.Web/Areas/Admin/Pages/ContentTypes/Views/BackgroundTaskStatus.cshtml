@page "/raytha/{contentTypeDeveloperName}/views/background-task/status/{id}"
@model Raytha.Web.Areas.Admin.Pages.Themes.BackgroundTaskStatus

@{
    var pageTitle = "Themes > Job in progress";
    Layout = "SidebarLayout";
    ViewData["Title"] = pageTitle;
    ViewData["ActiveMenu"] = "Themes";

    var back = new BackLinkOptions
    {
        Page = "/Themes/Index"
    };
}

<div class="row mb-4">
    <div class="col-xxl-7 col-xl-8 col-lg-9 col-md-12">
        <div class="card border-0 shadow mb-4">
            <div class="card-body">
                <div id="back-to-view" style="display:none;">
                    @(await Html.PartialAsync("_Partials/BackToList", back))
                </div>

                <div>
                    <div class="progress">
                        <div id="progress-bar" class="progress-bar" role="progressbar" aria-valuenow="0"
                            aria-valuemin="0" aria-valuemax="100">
                        </div>
                    </div>

                    <ul id="status-info" class="list-group">
                        <li class="list-group-item">Background task running...</li>
                    </ul>

                    <div class="d-flex justify-content-between"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    (function () {
        const progressBar = document.getElementById('progress-bar');
        const statusInfo = document.getElementById('status-info');
        const backToView = document.getElementById('back-to-view');

        // Provided by your PageModel
        const pathBase = '@Model.PathBase';
        const currentPath = window.location.pathname + '?json=true';

        let pollHandle = null;
        let currentTaskStep = 0;

        function setProgress(pct) {
            const clamped = Math.max(0, Math.min(100, Number(pct) || 0));
            progressBar.style.width = clamped + '%';
            progressBar.setAttribute('aria-valuenow', String(clamped));
        }

        function appendItem(text) {
            const li = document.createElement('li');
            li.className = 'list-group-item';
            li.textContent = text;
            statusInfo.appendChild(li);
        }

        function showBackLink() {
            if (backToView) backToView.style.display = '';
        }

        function stopPolling() {
            if (pollHandle) {
                clearInterval(pollHandle);
                pollHandle = null;
            }
        }

        function tryRedirectIfMediaInfo(raw) {
            if (!raw) return;
            try {
                const mediaItem = JSON.parse(raw);
                if (mediaItem && mediaItem.ObjectKey) {
                    const url = `${pathBase}/raytha/media-items/objectkey/${mediaItem.ObjectKey}`;
                    window.location.href = url;
                }
            } catch (_) {
                // statusInfo wasn't JSON; ignore
            }
        }

        async function refresh() {
            try {
                const res = await fetch(currentPath, { cache: 'no-store' });
                if (!res.ok) throw new Error('HTTP ' + res.status);
                const task = await res.json();

                const status = task?.status?.developerName; // 'processing' | 'enqueued' | 'error' | 'complete'
                const step = task?.taskStep;
                const pct = task?.percentComplete ?? 0;

                if (status === 'processing' || status === 'enqueued') {
                    if (currentTaskStep !== step) {
                        setProgress(pct);

                        if (task?.statusInfo) {
                            appendItem(task.statusInfo);
                        }

                        currentTaskStep = step;
                    }
                } else if (status === 'error') {
                    progressBar.classList.remove('bg-success');
                    progressBar.classList.add('bg-danger');
                    appendItem('An error has occurred: ' + (task?.errorMessage || 'Unknown error'));
                    setProgress(100);
                    showBackLink();
                    stopPolling();
                } else if (status === 'complete') {
                    progressBar.classList.remove('bg-danger');
                    progressBar.classList.add('bg-success');

                    if (task?.statusInfo) appendItem(task.statusInfo);
                    appendItem('Background task complete');

                    setProgress(100);
                    showBackLink();
                    stopPolling();

                    // Optional redirect if statusInfo contains media JSON
                    tryRedirectIfMediaInfo(task?.statusInfo);
                }
            } catch (err) {
                console.error('Status refresh failed:', err);
                // Donâ€™t stop polling on transient failures.
            }
        }

        // Start polling when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            // kick once immediately so the UI updates fast, then poll
            refresh();
            pollHandle = setInterval(refresh, 1000);
        });

        // Be nice to the browser when tab is hidden
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                stopPolling();
            } else if (!pollHandle) {
                refresh();
                pollHandle = setInterval(refresh, 1000);
            }
        });
    })();
</script>